--This file implements the logic that syncs two player's inputs
--author: TheOnlyOne
local sync = {}



--load configurations
local config = require("config")

local require_status, modify_inputs, display_inputs
--attempt to load the desired input modifier. If it does not exist, load the
--default modifier
require_status, modify_inputs = pcall(function()
  return require(config.input_modifier)
end)
if not require_status then
  console.log("The input modifier specified in config.lua could not be found.")
  console.log("Loading the default input modifier instead.")
  modify_inputs = require("inputmodifier_none")
end
--attempt to load the desired input display. If it does not exist, load the
--default display
require_status, display_inputs = pcall(function()
  return require(config.input_display)
end)
if not require_status then
  console.log("The input diplay specified in config.lua could not be found.")
  console.log("Loading the default input diplay instead.")
  display_inputs = require("inputdisplay_none")
end



--loads slot 0, this should be a savestate at frame 0
--such a savestate can be generated by running saveframe0.lua
function sync.synctoframe1()
  savestate.loadslot(0)
  console.log("Synced! Let the games begin!")
  emu.frameadvance()
end



--shares the input between two players, making sure that the same input is
--pressed for both players on every frame
function sync.syncallinput(client_socket)

  local messenger = require("messenger")
  local controller = require("controller")
  local keymap = require(controller.keymapfilename)

  --create input queues
  local my_input_queue = {}
  local their_input_queue = {}

  --set the first latency frames to no input
  for i = 1, config.latency do
    my_input_queue[i] = {}
    their_input_queue[i] = {}
  end

  local current_frame, future_frame
  local current_input, received_input
  local received_message_type, receivedr_data
  local received_frame
  local my_input, their_input, final_input

  while 1 do
    current_frame = emu.framecount()
    future_frame = current_frame + config.latency

    --get the player input, and add it to the queue
    current_input = controller.get(keymap)
    my_input_queue[future_frame] = current_input

    --send the input to the other player
    messenger.send(client_socket, messenger.INPUT, current_input, future_frame)

    --receive this frame's input from the other player
    while (their_input_queue[emu.framecount()] == nil) do
      received_message_type, received_data = messenger.receive(client_socket)
      if(received_message_type == messenger.INPUT) then
        --we received input
        received_input = received_data[1]
        received_frame = received_data[2]

        --add the input to the queue
        their_input_queue[received_frame] = received_input
      else
        error("Unexpected message type received.")
      end
    end

    --construct the input for the next frame
    final_input = {}
    my_input = my_input_queue[emu.framecount()]
    their_input = their_input_queue[emu.framecount()]

    my_input, their_input = modify_inputs(my_input, their_input, config.player)
    display_inputs(my_input, their_input, config.player)

    for i, b in pairs(controller.buttons) do
      if (my_input[b] == true or their_input[b] == true) then
        final_input[b] = true
      else
        final_input[b] = false
      end
    end

    --set the input
    joypad.set(final_input)

    --clear these entries to keep the queue size from growing
    my_input_queue[emu.framecount()] = nil
    their_input_queue[emu.framecount()] = nil

    emu.frameadvance()

    --clear all input so that actual inputs do not interfere
    joypad.set(controller.unset)
  end
end

return sync