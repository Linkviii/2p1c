--author: TheOnlyOne
local sync = {}

local config = require("config")
local modifyInputs = require("superstarsagamodifyinputs")

--loads slot 0, this should be a savestate at frame 0
--such a savestate can be generated by running saveframe0.lua
function sync.synctoframe1()
  savestate.loadslot(0)
  console.log("Synced! Let the games begin!")
  emu.frameadvance()
end

--TODO: clean this up!
function sync.syncallinput(client_socket, player)

  local buttons = {"A", "B", "L", "R", "Select", "Start", "Right", "Left", "Up", "Down"}

  local unset = {}
  for j, b in pairs(buttons) do
    unset[b] = false
  end

  --create input queues
  local input_queue = {}
  local peer_queue = {}

  --set the first latency frames to no input
  for i = 1, config.latency do
    input_queue[i] = {}
    peer_queue[i] = {}
    for j, b in pairs(buttons) do
      input_queue[i][b] = false
      peer_queue[i][b] = false
    end
  end

  local input_string, button_string
  local our_message, their_message
  local keys_pressed, current_input, their_input, final_input
  local their_frame

  keymap = require("keymap")

  while 1 do
    --get the player input
    keys_pressed = input.get()
    current_input = {}
    for k, b in pairs(keys_pressed) do
      if (keymap[k] ~= nil) then
        current_input[keymap[k]] = true
      end
    end

    input_queue[emu.framecount() + config.latency] = current_input

    --convert pressed buttons to a binary string
    input_string = ""
    for i, b in pairs(buttons) do
      if (current_input[b] == true) then
        input_string = input_string .. "1"
      else
        input_string = input_string .. "0"
      end
    end

    --send input
    our_message = input_string .. (emu.framecount() + config.latency)
    --console.log(our_message)
    client_socket:send(our_message .. "\n")

    --receive this frame's input from the peer
    if (emu.framecount() > config.latency) then
      while (peer_queue[emu.framecount()] == nil) do
        their_message, err = client_socket:receive()
        if(their_message == nil) then
          console.log(err)
          return
        else
          --get buttons from the message
          their_input = {}
          for i, b in pairs(buttons) do
            if (their_message:sub(i,i) == "1") then
              their_input[b] = true
            end
          end

          --get frame count from message
          their_frame = tonumber(their_message:sub(11))

          --add the input to the queue
          peer_queue[their_frame] = their_input
        end
      end
    end

    --construct the input for the next frame
    final_input = {}
    current_input = input_queue[emu.framecount()]
    their_input = peer_queue[emu.framecount()]
    modifyInputs(current_input, their_input, player)
    for i, b in pairs(buttons) do
      if (current_input[b] == true or their_input[b] == true) then
        final_input[b] = true
      else
        final_input[b] = false
      end
    end

    --set the input
    joypad.set(final_input)

    --clear these entries to keep the queue size from growing
    input_queue[emu.framecount()] = nil
    peer_queue[emu.framecount()] = nil

    emu.frameadvance()

    joypad.set(unset)
  end
end

return sync